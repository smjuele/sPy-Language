Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    OPENBRACE
    CHRLIT
    UNDERSCORE
    CLOSEBRACE
    COMMA
    IS
    MULTI_COMMENT
    break
    SINGLE_COMMENT
    BOOLEAN
    NOT
    QUOTATION

Grammar

Rule 0     S' -> main_program
Rule 1     main_program -> start OPENCURLY statement CLOSECURLY end
Rule 2     statement -> empty
Rule 3     empty -> <empty>
Rule 4     statement -> statement_list
Rule 5     statement_list -> statement
Rule 6     statement_list -> statement statement_list
Rule 7     statement -> VAR ASSIGN expression TILDE
Rule 8     statement -> VAR ASSIGN INTLIT TILDE
Rule 9     statement -> expression TILDE
Rule 10    statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
Rule 11    parameter -> INTLIT
Rule 12    parameter -> STRLIT
Rule 13    statement -> class VAR OPENCURLY statement CLOSECURLY
Rule 14    statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
Rule 15    statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
Rule 16    statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
Rule 17    statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
Rule 18    statement -> print OPENPAR expression CLOSEPAR TILDE
Rule 19    statement -> print OPENPAR STRLIT CLOSEPAR TILDE
Rule 20    statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
Rule 21    statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
Rule 22    statement -> if_statement
Rule 23    if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
Rule 24    if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
Rule 25    if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
Rule 26    if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
Rule 27    statement -> while_stmt
Rule 28    while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
Rule 29    expression -> term
Rule 30    expression -> boolean
Rule 31    boolean -> expression GT term
Rule 32    boolean -> expression GEQ term
Rule 33    boolean -> expression LT term
Rule 34    boolean -> expression LEQ term
Rule 35    boolean -> expression EQ term
Rule 36    boolean -> expression NEQ term
Rule 37    boolean -> expression AND term
Rule 38    boolean -> expression OR term
Rule 39    boolean -> expression is term
Rule 40    expression -> expression PLUS term
Rule 41    expression -> expression MINUS term
Rule 42    term -> term MUL factor
Rule 43    term -> term DIV factor
Rule 44    term -> term MOD factor
Rule 45    term -> STRLIT
Rule 46    term -> factor
Rule 47    factor -> INTLIT
Rule 48    factor -> FLTLIT
Rule 49    factor -> DBLLIT
Rule 50    factor -> OPENPAR expression CLOSEPAR

Terminals, with rules where they appear

AND                  : 37
ASSIGN               : 7 8 14 15 16 17 20 21 28
BOOLEAN              : 
CHRLIT               : 
CLOSEBRACE           : 
CLOSECURLY           : 1 10 13 23 24 25 26 28
CLOSEPAR             : 10 14 14 15 15 16 17 18 19 20 21 23 24 24 24 25 25 25 26 26 26 28 50
COMMA                : 
DBLLIT               : 49
DIV                  : 43
EQ                   : 35
FLTLIT               : 48
GEQ                  : 32
GT                   : 31
INTLIT               : 8 11 25 25 28 47
IS                   : 
LEQ                  : 34
LT                   : 33
MINUS                : 41
MOD                  : 44
MUL                  : 42
MULTI_COMMENT        : 
NEQ                  : 36
NOT                  : 
OPENBRACE            : 
OPENCURLY            : 1 10 13 23 24 25 26 28
OPENPAR              : 10 14 14 15 15 16 17 18 19 20 21 23 24 24 24 25 25 25 26 26 26 28 50
OR                   : 38
PLUS                 : 40
QUOTATION            : 
SINGLE_COMMENT       : 
STRLIT               : 12 15 17 19 21 24 24 45
TILDE                : 7 8 9 14 14 15 15 16 16 17 17 18 19 20 20 21 21 24 24 25 25 26 26 28
UNDERSCORE           : 
VAR                  : 7 8 10 13 14 14 15 15 16 16 17 17 20 20 21 21 28
break                : 
class                : 13
def                  : 10
else                 : 24 25 26
end                  : 1
end_def              : 10
error                : 
if                   : 23 24 25 26
is                   : 39
print                : 18 19 20 21 24 24 25 25 26 26
return               : 16 17
scan                 : 14 15
start                : 1
while                : 28

Nonterminals, with rules where they appear

boolean              : 23 24 25 26 28 30
empty                : 2
expression           : 7 9 14 16 18 20 26 26 31 32 33 34 35 36 37 38 39 40 41 50
factor               : 42 43 44 46
if_statement         : 22 28
main_program         : 0
parameter            : 
statement            : 1 5 6 10 13 23 28
statement_list       : 4 6
term                 : 29 31 32 33 34 35 36 37 38 39 40 41 42 43 44
while_stmt           : 27

Parsing method: LALR

state 0

    (0) S' -> . main_program
    (1) main_program -> . start OPENCURLY statement CLOSECURLY end

    start           shift and go to state 1

    main_program                   shift and go to state 2

state 1

    (1) main_program -> start . OPENCURLY statement CLOSECURLY end

    OPENCURLY       shift and go to state 3


state 2

    (0) S' -> main_program .



state 3

    (1) main_program -> start OPENCURLY . statement CLOSECURLY end
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 9
    factor                         shift and go to state 13
    statement_list                 shift and go to state 20
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 4

    (49) factor -> DBLLIT .

    MUL             reduce using rule 49 (factor -> DBLLIT .)
    DIV             reduce using rule 49 (factor -> DBLLIT .)
    MOD             reduce using rule 49 (factor -> DBLLIT .)
    TILDE           reduce using rule 49 (factor -> DBLLIT .)
    PLUS            reduce using rule 49 (factor -> DBLLIT .)
    MINUS           reduce using rule 49 (factor -> DBLLIT .)
    GT              reduce using rule 49 (factor -> DBLLIT .)
    GEQ             reduce using rule 49 (factor -> DBLLIT .)
    LT              reduce using rule 49 (factor -> DBLLIT .)
    LEQ             reduce using rule 49 (factor -> DBLLIT .)
    EQ              reduce using rule 49 (factor -> DBLLIT .)
    NEQ             reduce using rule 49 (factor -> DBLLIT .)
    AND             reduce using rule 49 (factor -> DBLLIT .)
    OR              reduce using rule 49 (factor -> DBLLIT .)
    is              reduce using rule 49 (factor -> DBLLIT .)
    CLOSEPAR        reduce using rule 49 (factor -> DBLLIT .)


state 5

    (50) factor -> OPENPAR . expression CLOSEPAR
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 17
    boolean                        shift and go to state 6
    expression                     shift and go to state 23
    factor                         shift and go to state 13

state 6

    (30) expression -> boolean .

    TILDE           reduce using rule 30 (expression -> boolean .)
    PLUS            reduce using rule 30 (expression -> boolean .)
    MINUS           reduce using rule 30 (expression -> boolean .)
    GT              reduce using rule 30 (expression -> boolean .)
    GEQ             reduce using rule 30 (expression -> boolean .)
    LT              reduce using rule 30 (expression -> boolean .)
    LEQ             reduce using rule 30 (expression -> boolean .)
    EQ              reduce using rule 30 (expression -> boolean .)
    NEQ             reduce using rule 30 (expression -> boolean .)
    AND             reduce using rule 30 (expression -> boolean .)
    OR              reduce using rule 30 (expression -> boolean .)
    is              reduce using rule 30 (expression -> boolean .)
    CLOSEPAR        reduce using rule 30 (expression -> boolean .)


state 7

    (47) factor -> INTLIT .

    MUL             reduce using rule 47 (factor -> INTLIT .)
    DIV             reduce using rule 47 (factor -> INTLIT .)
    MOD             reduce using rule 47 (factor -> INTLIT .)
    TILDE           reduce using rule 47 (factor -> INTLIT .)
    PLUS            reduce using rule 47 (factor -> INTLIT .)
    MINUS           reduce using rule 47 (factor -> INTLIT .)
    GT              reduce using rule 47 (factor -> INTLIT .)
    GEQ             reduce using rule 47 (factor -> INTLIT .)
    LT              reduce using rule 47 (factor -> INTLIT .)
    LEQ             reduce using rule 47 (factor -> INTLIT .)
    EQ              reduce using rule 47 (factor -> INTLIT .)
    NEQ             reduce using rule 47 (factor -> INTLIT .)
    AND             reduce using rule 47 (factor -> INTLIT .)
    OR              reduce using rule 47 (factor -> INTLIT .)
    is              reduce using rule 47 (factor -> INTLIT .)
    CLOSEPAR        reduce using rule 47 (factor -> INTLIT .)


state 8

    (23) if_statement -> if . OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> if . OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> if . OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> if . OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    OPENPAR         shift and go to state 24


state 9

    (1) main_program -> start OPENCURLY statement . CLOSECURLY end
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for FLTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for DBLLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 25
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! FLTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! DBLLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 26
    factor                         shift and go to state 13
    statement_list                 shift and go to state 27
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 10

    (18) statement -> print . OPENPAR expression CLOSEPAR TILDE
    (19) statement -> print . OPENPAR STRLIT CLOSEPAR TILDE

    OPENPAR         shift and go to state 28


state 11

    (22) statement -> if_statement .

    CLOSECURLY      reduce using rule 22 (statement -> if_statement .)
    VAR             reduce using rule 22 (statement -> if_statement .)
    def             reduce using rule 22 (statement -> if_statement .)
    class           reduce using rule 22 (statement -> if_statement .)
    print           reduce using rule 22 (statement -> if_statement .)
    if              reduce using rule 22 (statement -> if_statement .)
    STRLIT          reduce using rule 22 (statement -> if_statement .)
    INTLIT          reduce using rule 22 (statement -> if_statement .)
    FLTLIT          reduce using rule 22 (statement -> if_statement .)
    DBLLIT          reduce using rule 22 (statement -> if_statement .)
    OPENPAR         reduce using rule 22 (statement -> if_statement .)


state 12

    (2) statement -> empty .

    CLOSECURLY      reduce using rule 2 (statement -> empty .)
    VAR             reduce using rule 2 (statement -> empty .)
    def             reduce using rule 2 (statement -> empty .)
    class           reduce using rule 2 (statement -> empty .)
    print           reduce using rule 2 (statement -> empty .)
    if              reduce using rule 2 (statement -> empty .)
    STRLIT          reduce using rule 2 (statement -> empty .)
    INTLIT          reduce using rule 2 (statement -> empty .)
    FLTLIT          reduce using rule 2 (statement -> empty .)
    DBLLIT          reduce using rule 2 (statement -> empty .)
    OPENPAR         reduce using rule 2 (statement -> empty .)


state 13

    (46) term -> factor .

    MUL             reduce using rule 46 (term -> factor .)
    DIV             reduce using rule 46 (term -> factor .)
    MOD             reduce using rule 46 (term -> factor .)
    TILDE           reduce using rule 46 (term -> factor .)
    PLUS            reduce using rule 46 (term -> factor .)
    MINUS           reduce using rule 46 (term -> factor .)
    GT              reduce using rule 46 (term -> factor .)
    GEQ             reduce using rule 46 (term -> factor .)
    LT              reduce using rule 46 (term -> factor .)
    LEQ             reduce using rule 46 (term -> factor .)
    EQ              reduce using rule 46 (term -> factor .)
    NEQ             reduce using rule 46 (term -> factor .)
    AND             reduce using rule 46 (term -> factor .)
    OR              reduce using rule 46 (term -> factor .)
    is              reduce using rule 46 (term -> factor .)
    CLOSEPAR        reduce using rule 46 (term -> factor .)


state 14

    (45) term -> STRLIT .

    MUL             reduce using rule 45 (term -> STRLIT .)
    DIV             reduce using rule 45 (term -> STRLIT .)
    MOD             reduce using rule 45 (term -> STRLIT .)
    TILDE           reduce using rule 45 (term -> STRLIT .)
    PLUS            reduce using rule 45 (term -> STRLIT .)
    MINUS           reduce using rule 45 (term -> STRLIT .)
    GT              reduce using rule 45 (term -> STRLIT .)
    GEQ             reduce using rule 45 (term -> STRLIT .)
    LT              reduce using rule 45 (term -> STRLIT .)
    LEQ             reduce using rule 45 (term -> STRLIT .)
    EQ              reduce using rule 45 (term -> STRLIT .)
    NEQ             reduce using rule 45 (term -> STRLIT .)
    AND             reduce using rule 45 (term -> STRLIT .)
    OR              reduce using rule 45 (term -> STRLIT .)
    is              reduce using rule 45 (term -> STRLIT .)
    CLOSEPAR        reduce using rule 45 (term -> STRLIT .)


state 15

    (7) statement -> VAR . ASSIGN expression TILDE
    (8) statement -> VAR . ASSIGN INTLIT TILDE
    (14) statement -> VAR . ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR . ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR . ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> VAR . ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR . ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> VAR . ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (28) while_stmt -> VAR . ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement

    ASSIGN          shift and go to state 29


state 16

    (13) statement -> class . VAR OPENCURLY statement CLOSECURLY

    VAR             shift and go to state 30


state 17

    (29) expression -> term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 29 (expression -> term .)
    PLUS            reduce using rule 29 (expression -> term .)
    MINUS           reduce using rule 29 (expression -> term .)
    GT              reduce using rule 29 (expression -> term .)
    GEQ             reduce using rule 29 (expression -> term .)
    LT              reduce using rule 29 (expression -> term .)
    LEQ             reduce using rule 29 (expression -> term .)
    EQ              reduce using rule 29 (expression -> term .)
    NEQ             reduce using rule 29 (expression -> term .)
    AND             reduce using rule 29 (expression -> term .)
    OR              reduce using rule 29 (expression -> term .)
    is              reduce using rule 29 (expression -> term .)
    CLOSEPAR        reduce using rule 29 (expression -> term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 18

    (48) factor -> FLTLIT .

    MUL             reduce using rule 48 (factor -> FLTLIT .)
    DIV             reduce using rule 48 (factor -> FLTLIT .)
    MOD             reduce using rule 48 (factor -> FLTLIT .)
    TILDE           reduce using rule 48 (factor -> FLTLIT .)
    PLUS            reduce using rule 48 (factor -> FLTLIT .)
    MINUS           reduce using rule 48 (factor -> FLTLIT .)
    GT              reduce using rule 48 (factor -> FLTLIT .)
    GEQ             reduce using rule 48 (factor -> FLTLIT .)
    LT              reduce using rule 48 (factor -> FLTLIT .)
    LEQ             reduce using rule 48 (factor -> FLTLIT .)
    EQ              reduce using rule 48 (factor -> FLTLIT .)
    NEQ             reduce using rule 48 (factor -> FLTLIT .)
    AND             reduce using rule 48 (factor -> FLTLIT .)
    OR              reduce using rule 48 (factor -> FLTLIT .)
    is              reduce using rule 48 (factor -> FLTLIT .)
    CLOSEPAR        reduce using rule 48 (factor -> FLTLIT .)


state 19

    (27) statement -> while_stmt .

    CLOSECURLY      reduce using rule 27 (statement -> while_stmt .)
    VAR             reduce using rule 27 (statement -> while_stmt .)
    def             reduce using rule 27 (statement -> while_stmt .)
    class           reduce using rule 27 (statement -> while_stmt .)
    print           reduce using rule 27 (statement -> while_stmt .)
    if              reduce using rule 27 (statement -> while_stmt .)
    STRLIT          reduce using rule 27 (statement -> while_stmt .)
    INTLIT          reduce using rule 27 (statement -> while_stmt .)
    FLTLIT          reduce using rule 27 (statement -> while_stmt .)
    DBLLIT          reduce using rule 27 (statement -> while_stmt .)
    OPENPAR         reduce using rule 27 (statement -> while_stmt .)


state 20

    (4) statement -> statement_list .

    CLOSECURLY      reduce using rule 4 (statement -> statement_list .)
    VAR             reduce using rule 4 (statement -> statement_list .)
    def             reduce using rule 4 (statement -> statement_list .)
    class           reduce using rule 4 (statement -> statement_list .)
    print           reduce using rule 4 (statement -> statement_list .)
    if              reduce using rule 4 (statement -> statement_list .)
    STRLIT          reduce using rule 4 (statement -> statement_list .)
    INTLIT          reduce using rule 4 (statement -> statement_list .)
    FLTLIT          reduce using rule 4 (statement -> statement_list .)
    DBLLIT          reduce using rule 4 (statement -> statement_list .)
    OPENPAR         reduce using rule 4 (statement -> statement_list .)


state 21

    (9) statement -> expression . TILDE
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term
    (31) boolean -> expression . GT term
    (32) boolean -> expression . GEQ term
    (33) boolean -> expression . LT term
    (34) boolean -> expression . LEQ term
    (35) boolean -> expression . EQ term
    (36) boolean -> expression . NEQ term
    (37) boolean -> expression . AND term
    (38) boolean -> expression . OR term
    (39) boolean -> expression . is term

    TILDE           shift and go to state 43
    PLUS            shift and go to state 42
    MINUS           shift and go to state 44
    GT              shift and go to state 35
    GEQ             shift and go to state 38
    LT              shift and go to state 41
    LEQ             shift and go to state 40
    EQ              shift and go to state 36
    NEQ             shift and go to state 45
    AND             shift and go to state 34
    OR              shift and go to state 39
    is              shift and go to state 37


state 22

    (10) statement -> def . VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    VAR             shift and go to state 46


state 23

    (50) factor -> OPENPAR expression . CLOSEPAR
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term
    (31) boolean -> expression . GT term
    (32) boolean -> expression . GEQ term
    (33) boolean -> expression . LT term
    (34) boolean -> expression . LEQ term
    (35) boolean -> expression . EQ term
    (36) boolean -> expression . NEQ term
    (37) boolean -> expression . AND term
    (38) boolean -> expression . OR term
    (39) boolean -> expression . is term

    CLOSEPAR        shift and go to state 47
    PLUS            shift and go to state 42
    MINUS           shift and go to state 44
    GT              shift and go to state 35
    GEQ             shift and go to state 38
    LT              shift and go to state 41
    LEQ             shift and go to state 40
    EQ              shift and go to state 36
    NEQ             shift and go to state 45
    AND             shift and go to state 34
    OR              shift and go to state 39
    is              shift and go to state 37


state 24

    (23) if_statement -> if OPENPAR . boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> if OPENPAR . boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> if OPENPAR . boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> if OPENPAR . boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 17
    boolean                        shift and go to state 48
    expression                     shift and go to state 49
    factor                         shift and go to state 13

state 25

    (1) main_program -> start OPENCURLY statement CLOSECURLY . end

    end             shift and go to state 50


state 26

    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for CLOSECURLY resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for FLTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for DBLLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! FLTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! DBLLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 26
    factor                         shift and go to state 13
    statement_list                 shift and go to state 27
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 27

    (6) statement_list -> statement statement_list .
    (4) statement -> statement_list .

  ! reduce/reduce conflict for CLOSECURLY resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for VAR resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for def resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for class resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for print resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for if resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for STRLIT resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for INTLIT resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for FLTLIT resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for DBLLIT resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 4 (statement -> statement_list .)
    CLOSECURLY      reduce using rule 4 (statement -> statement_list .)
    VAR             reduce using rule 4 (statement -> statement_list .)
    def             reduce using rule 4 (statement -> statement_list .)
    class           reduce using rule 4 (statement -> statement_list .)
    print           reduce using rule 4 (statement -> statement_list .)
    if              reduce using rule 4 (statement -> statement_list .)
    STRLIT          reduce using rule 4 (statement -> statement_list .)
    INTLIT          reduce using rule 4 (statement -> statement_list .)
    FLTLIT          reduce using rule 4 (statement -> statement_list .)
    DBLLIT          reduce using rule 4 (statement -> statement_list .)
    OPENPAR         reduce using rule 4 (statement -> statement_list .)

  ! CLOSECURLY      [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! VAR             [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! def             [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! class           [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! print           [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! if              [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! STRLIT          [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! INTLIT          [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! FLTLIT          [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! DBLLIT          [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! OPENPAR         [ reduce using rule 6 (statement_list -> statement statement_list .) ]


state 28

    (18) statement -> print OPENPAR . expression CLOSEPAR TILDE
    (19) statement -> print OPENPAR . STRLIT CLOSEPAR TILDE
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 51
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 17
    boolean                        shift and go to state 6
    expression                     shift and go to state 52
    factor                         shift and go to state 13

state 29

    (7) statement -> VAR ASSIGN . expression TILDE
    (8) statement -> VAR ASSIGN . INTLIT TILDE
    (14) statement -> VAR ASSIGN . OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR ASSIGN . OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR ASSIGN . expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> VAR ASSIGN . STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN . expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> VAR ASSIGN . STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (28) while_stmt -> VAR ASSIGN . INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 54
    OPENPAR         shift and go to state 53
    STRLIT          shift and go to state 55
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4

    term                           shift and go to state 17
    boolean                        shift and go to state 6
    factor                         shift and go to state 13
    expression                     shift and go to state 56

state 30

    (13) statement -> class VAR . OPENCURLY statement CLOSECURLY

    OPENCURLY       shift and go to state 57


state 31

    (42) term -> term MUL . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    factor                         shift and go to state 58

state 32

    (44) term -> term MOD . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    factor                         shift and go to state 59

state 33

    (43) term -> term DIV . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    factor                         shift and go to state 60

state 34

    (37) boolean -> expression AND . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 61
    factor                         shift and go to state 13

state 35

    (31) boolean -> expression GT . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 62
    factor                         shift and go to state 13

state 36

    (35) boolean -> expression EQ . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 63
    factor                         shift and go to state 13

state 37

    (39) boolean -> expression is . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 64
    factor                         shift and go to state 13

state 38

    (32) boolean -> expression GEQ . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 65
    factor                         shift and go to state 13

state 39

    (38) boolean -> expression OR . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 66
    factor                         shift and go to state 13

state 40

    (34) boolean -> expression LEQ . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 67
    factor                         shift and go to state 13

state 41

    (33) boolean -> expression LT . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 68
    factor                         shift and go to state 13

state 42

    (40) expression -> expression PLUS . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 69
    factor                         shift and go to state 13

state 43

    (9) statement -> expression TILDE .

    CLOSECURLY      reduce using rule 9 (statement -> expression TILDE .)
    VAR             reduce using rule 9 (statement -> expression TILDE .)
    def             reduce using rule 9 (statement -> expression TILDE .)
    class           reduce using rule 9 (statement -> expression TILDE .)
    print           reduce using rule 9 (statement -> expression TILDE .)
    if              reduce using rule 9 (statement -> expression TILDE .)
    STRLIT          reduce using rule 9 (statement -> expression TILDE .)
    INTLIT          reduce using rule 9 (statement -> expression TILDE .)
    FLTLIT          reduce using rule 9 (statement -> expression TILDE .)
    DBLLIT          reduce using rule 9 (statement -> expression TILDE .)
    OPENPAR         reduce using rule 9 (statement -> expression TILDE .)


state 44

    (41) expression -> expression MINUS . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 70
    factor                         shift and go to state 13

state 45

    (36) boolean -> expression NEQ . term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 71
    factor                         shift and go to state 13

state 46

    (10) statement -> def VAR . OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    OPENPAR         shift and go to state 72


state 47

    (50) factor -> OPENPAR expression CLOSEPAR .

    MUL             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    DIV             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    MOD             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    TILDE           reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    PLUS            reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    MINUS           reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    GT              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    GEQ             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    LT              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    LEQ             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    EQ              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    NEQ             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    AND             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    OR              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    is              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    CLOSEPAR        reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)


state 48

    (23) if_statement -> if OPENPAR boolean . CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> if OPENPAR boolean . CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> if OPENPAR boolean . CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> if OPENPAR boolean . CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (30) expression -> boolean .

    CLOSEPAR        shift and go to state 73
    GT              reduce using rule 30 (expression -> boolean .)
    GEQ             reduce using rule 30 (expression -> boolean .)
    LT              reduce using rule 30 (expression -> boolean .)
    LEQ             reduce using rule 30 (expression -> boolean .)
    EQ              reduce using rule 30 (expression -> boolean .)
    NEQ             reduce using rule 30 (expression -> boolean .)
    AND             reduce using rule 30 (expression -> boolean .)
    OR              reduce using rule 30 (expression -> boolean .)
    is              reduce using rule 30 (expression -> boolean .)
    PLUS            reduce using rule 30 (expression -> boolean .)
    MINUS           reduce using rule 30 (expression -> boolean .)


state 49

    (31) boolean -> expression . GT term
    (32) boolean -> expression . GEQ term
    (33) boolean -> expression . LT term
    (34) boolean -> expression . LEQ term
    (35) boolean -> expression . EQ term
    (36) boolean -> expression . NEQ term
    (37) boolean -> expression . AND term
    (38) boolean -> expression . OR term
    (39) boolean -> expression . is term
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term

    GT              shift and go to state 35
    GEQ             shift and go to state 38
    LT              shift and go to state 41
    LEQ             shift and go to state 40
    EQ              shift and go to state 36
    NEQ             shift and go to state 45
    AND             shift and go to state 34
    OR              shift and go to state 39
    is              shift and go to state 37
    PLUS            shift and go to state 42
    MINUS           shift and go to state 44


state 50

    (1) main_program -> start OPENCURLY statement CLOSECURLY end .

    $end            reduce using rule 1 (main_program -> start OPENCURLY statement CLOSECURLY end .)


state 51

    (19) statement -> print OPENPAR STRLIT . CLOSEPAR TILDE
    (45) term -> STRLIT .

  ! shift/reduce conflict for CLOSEPAR resolved as shift
    CLOSEPAR        shift and go to state 74
    MUL             reduce using rule 45 (term -> STRLIT .)
    DIV             reduce using rule 45 (term -> STRLIT .)
    MOD             reduce using rule 45 (term -> STRLIT .)
    PLUS            reduce using rule 45 (term -> STRLIT .)
    MINUS           reduce using rule 45 (term -> STRLIT .)
    GT              reduce using rule 45 (term -> STRLIT .)
    GEQ             reduce using rule 45 (term -> STRLIT .)
    LT              reduce using rule 45 (term -> STRLIT .)
    LEQ             reduce using rule 45 (term -> STRLIT .)
    EQ              reduce using rule 45 (term -> STRLIT .)
    NEQ             reduce using rule 45 (term -> STRLIT .)
    AND             reduce using rule 45 (term -> STRLIT .)
    OR              reduce using rule 45 (term -> STRLIT .)
    is              reduce using rule 45 (term -> STRLIT .)

  ! CLOSEPAR        [ reduce using rule 45 (term -> STRLIT .) ]


state 52

    (18) statement -> print OPENPAR expression . CLOSEPAR TILDE
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term
    (31) boolean -> expression . GT term
    (32) boolean -> expression . GEQ term
    (33) boolean -> expression . LT term
    (34) boolean -> expression . LEQ term
    (35) boolean -> expression . EQ term
    (36) boolean -> expression . NEQ term
    (37) boolean -> expression . AND term
    (38) boolean -> expression . OR term
    (39) boolean -> expression . is term

    CLOSEPAR        shift and go to state 75
    PLUS            shift and go to state 42
    MINUS           shift and go to state 44
    GT              shift and go to state 35
    GEQ             shift and go to state 38
    LT              shift and go to state 41
    LEQ             shift and go to state 40
    EQ              shift and go to state 36
    NEQ             shift and go to state 45
    AND             shift and go to state 34
    OR              shift and go to state 39
    is              shift and go to state 37


state 53

    (14) statement -> VAR ASSIGN OPENPAR . expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR ASSIGN OPENPAR . STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (50) factor -> OPENPAR . expression CLOSEPAR
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 76
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 17
    boolean                        shift and go to state 6
    expression                     shift and go to state 77
    factor                         shift and go to state 13

state 54

    (8) statement -> VAR ASSIGN INTLIT . TILDE
    (28) while_stmt -> VAR ASSIGN INTLIT . TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (47) factor -> INTLIT .

  ! shift/reduce conflict for TILDE resolved as shift
    TILDE           shift and go to state 78
    MUL             reduce using rule 47 (factor -> INTLIT .)
    DIV             reduce using rule 47 (factor -> INTLIT .)
    MOD             reduce using rule 47 (factor -> INTLIT .)
    PLUS            reduce using rule 47 (factor -> INTLIT .)
    MINUS           reduce using rule 47 (factor -> INTLIT .)
    GT              reduce using rule 47 (factor -> INTLIT .)
    GEQ             reduce using rule 47 (factor -> INTLIT .)
    LT              reduce using rule 47 (factor -> INTLIT .)
    LEQ             reduce using rule 47 (factor -> INTLIT .)
    EQ              reduce using rule 47 (factor -> INTLIT .)
    NEQ             reduce using rule 47 (factor -> INTLIT .)
    AND             reduce using rule 47 (factor -> INTLIT .)
    OR              reduce using rule 47 (factor -> INTLIT .)
    is              reduce using rule 47 (factor -> INTLIT .)

  ! TILDE           [ reduce using rule 47 (factor -> INTLIT .) ]


state 55

    (17) statement -> VAR ASSIGN STRLIT . TILDE return OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> VAR ASSIGN STRLIT . TILDE print OPENPAR VAR CLOSEPAR TILDE
    (45) term -> STRLIT .

  ! shift/reduce conflict for TILDE resolved as shift
    TILDE           shift and go to state 79
    MUL             reduce using rule 45 (term -> STRLIT .)
    DIV             reduce using rule 45 (term -> STRLIT .)
    MOD             reduce using rule 45 (term -> STRLIT .)
    PLUS            reduce using rule 45 (term -> STRLIT .)
    MINUS           reduce using rule 45 (term -> STRLIT .)
    GT              reduce using rule 45 (term -> STRLIT .)
    GEQ             reduce using rule 45 (term -> STRLIT .)
    LT              reduce using rule 45 (term -> STRLIT .)
    LEQ             reduce using rule 45 (term -> STRLIT .)
    EQ              reduce using rule 45 (term -> STRLIT .)
    NEQ             reduce using rule 45 (term -> STRLIT .)
    AND             reduce using rule 45 (term -> STRLIT .)
    OR              reduce using rule 45 (term -> STRLIT .)
    is              reduce using rule 45 (term -> STRLIT .)

  ! TILDE           [ reduce using rule 45 (term -> STRLIT .) ]


state 56

    (7) statement -> VAR ASSIGN expression . TILDE
    (16) statement -> VAR ASSIGN expression . TILDE return OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN expression . TILDE print OPENPAR VAR CLOSEPAR TILDE
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term
    (31) boolean -> expression . GT term
    (32) boolean -> expression . GEQ term
    (33) boolean -> expression . LT term
    (34) boolean -> expression . LEQ term
    (35) boolean -> expression . EQ term
    (36) boolean -> expression . NEQ term
    (37) boolean -> expression . AND term
    (38) boolean -> expression . OR term
    (39) boolean -> expression . is term

    TILDE           shift and go to state 80
    PLUS            shift and go to state 42
    MINUS           shift and go to state 44
    GT              shift and go to state 35
    GEQ             shift and go to state 38
    LT              shift and go to state 41
    LEQ             shift and go to state 40
    EQ              shift and go to state 36
    NEQ             shift and go to state 45
    AND             shift and go to state 34
    OR              shift and go to state 39
    is              shift and go to state 37


state 57

    (13) statement -> class VAR OPENCURLY . statement CLOSECURLY
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 81
    factor                         shift and go to state 13
    statement_list                 shift and go to state 20
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 58

    (42) term -> term MUL factor .

    MUL             reduce using rule 42 (term -> term MUL factor .)
    DIV             reduce using rule 42 (term -> term MUL factor .)
    MOD             reduce using rule 42 (term -> term MUL factor .)
    TILDE           reduce using rule 42 (term -> term MUL factor .)
    PLUS            reduce using rule 42 (term -> term MUL factor .)
    MINUS           reduce using rule 42 (term -> term MUL factor .)
    GT              reduce using rule 42 (term -> term MUL factor .)
    GEQ             reduce using rule 42 (term -> term MUL factor .)
    LT              reduce using rule 42 (term -> term MUL factor .)
    LEQ             reduce using rule 42 (term -> term MUL factor .)
    EQ              reduce using rule 42 (term -> term MUL factor .)
    NEQ             reduce using rule 42 (term -> term MUL factor .)
    AND             reduce using rule 42 (term -> term MUL factor .)
    OR              reduce using rule 42 (term -> term MUL factor .)
    is              reduce using rule 42 (term -> term MUL factor .)
    CLOSEPAR        reduce using rule 42 (term -> term MUL factor .)


state 59

    (44) term -> term MOD factor .

    MUL             reduce using rule 44 (term -> term MOD factor .)
    DIV             reduce using rule 44 (term -> term MOD factor .)
    MOD             reduce using rule 44 (term -> term MOD factor .)
    TILDE           reduce using rule 44 (term -> term MOD factor .)
    PLUS            reduce using rule 44 (term -> term MOD factor .)
    MINUS           reduce using rule 44 (term -> term MOD factor .)
    GT              reduce using rule 44 (term -> term MOD factor .)
    GEQ             reduce using rule 44 (term -> term MOD factor .)
    LT              reduce using rule 44 (term -> term MOD factor .)
    LEQ             reduce using rule 44 (term -> term MOD factor .)
    EQ              reduce using rule 44 (term -> term MOD factor .)
    NEQ             reduce using rule 44 (term -> term MOD factor .)
    AND             reduce using rule 44 (term -> term MOD factor .)
    OR              reduce using rule 44 (term -> term MOD factor .)
    is              reduce using rule 44 (term -> term MOD factor .)
    CLOSEPAR        reduce using rule 44 (term -> term MOD factor .)


state 60

    (43) term -> term DIV factor .

    MUL             reduce using rule 43 (term -> term DIV factor .)
    DIV             reduce using rule 43 (term -> term DIV factor .)
    MOD             reduce using rule 43 (term -> term DIV factor .)
    TILDE           reduce using rule 43 (term -> term DIV factor .)
    PLUS            reduce using rule 43 (term -> term DIV factor .)
    MINUS           reduce using rule 43 (term -> term DIV factor .)
    GT              reduce using rule 43 (term -> term DIV factor .)
    GEQ             reduce using rule 43 (term -> term DIV factor .)
    LT              reduce using rule 43 (term -> term DIV factor .)
    LEQ             reduce using rule 43 (term -> term DIV factor .)
    EQ              reduce using rule 43 (term -> term DIV factor .)
    NEQ             reduce using rule 43 (term -> term DIV factor .)
    AND             reduce using rule 43 (term -> term DIV factor .)
    OR              reduce using rule 43 (term -> term DIV factor .)
    is              reduce using rule 43 (term -> term DIV factor .)
    CLOSEPAR        reduce using rule 43 (term -> term DIV factor .)


state 61

    (37) boolean -> expression AND term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 37 (boolean -> expression AND term .)
    PLUS            reduce using rule 37 (boolean -> expression AND term .)
    MINUS           reduce using rule 37 (boolean -> expression AND term .)
    GT              reduce using rule 37 (boolean -> expression AND term .)
    GEQ             reduce using rule 37 (boolean -> expression AND term .)
    LT              reduce using rule 37 (boolean -> expression AND term .)
    LEQ             reduce using rule 37 (boolean -> expression AND term .)
    EQ              reduce using rule 37 (boolean -> expression AND term .)
    NEQ             reduce using rule 37 (boolean -> expression AND term .)
    AND             reduce using rule 37 (boolean -> expression AND term .)
    OR              reduce using rule 37 (boolean -> expression AND term .)
    is              reduce using rule 37 (boolean -> expression AND term .)
    CLOSEPAR        reduce using rule 37 (boolean -> expression AND term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 62

    (31) boolean -> expression GT term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 31 (boolean -> expression GT term .)
    PLUS            reduce using rule 31 (boolean -> expression GT term .)
    MINUS           reduce using rule 31 (boolean -> expression GT term .)
    GT              reduce using rule 31 (boolean -> expression GT term .)
    GEQ             reduce using rule 31 (boolean -> expression GT term .)
    LT              reduce using rule 31 (boolean -> expression GT term .)
    LEQ             reduce using rule 31 (boolean -> expression GT term .)
    EQ              reduce using rule 31 (boolean -> expression GT term .)
    NEQ             reduce using rule 31 (boolean -> expression GT term .)
    AND             reduce using rule 31 (boolean -> expression GT term .)
    OR              reduce using rule 31 (boolean -> expression GT term .)
    is              reduce using rule 31 (boolean -> expression GT term .)
    CLOSEPAR        reduce using rule 31 (boolean -> expression GT term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 63

    (35) boolean -> expression EQ term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 35 (boolean -> expression EQ term .)
    PLUS            reduce using rule 35 (boolean -> expression EQ term .)
    MINUS           reduce using rule 35 (boolean -> expression EQ term .)
    GT              reduce using rule 35 (boolean -> expression EQ term .)
    GEQ             reduce using rule 35 (boolean -> expression EQ term .)
    LT              reduce using rule 35 (boolean -> expression EQ term .)
    LEQ             reduce using rule 35 (boolean -> expression EQ term .)
    EQ              reduce using rule 35 (boolean -> expression EQ term .)
    NEQ             reduce using rule 35 (boolean -> expression EQ term .)
    AND             reduce using rule 35 (boolean -> expression EQ term .)
    OR              reduce using rule 35 (boolean -> expression EQ term .)
    is              reduce using rule 35 (boolean -> expression EQ term .)
    CLOSEPAR        reduce using rule 35 (boolean -> expression EQ term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 64

    (39) boolean -> expression is term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 39 (boolean -> expression is term .)
    PLUS            reduce using rule 39 (boolean -> expression is term .)
    MINUS           reduce using rule 39 (boolean -> expression is term .)
    GT              reduce using rule 39 (boolean -> expression is term .)
    GEQ             reduce using rule 39 (boolean -> expression is term .)
    LT              reduce using rule 39 (boolean -> expression is term .)
    LEQ             reduce using rule 39 (boolean -> expression is term .)
    EQ              reduce using rule 39 (boolean -> expression is term .)
    NEQ             reduce using rule 39 (boolean -> expression is term .)
    AND             reduce using rule 39 (boolean -> expression is term .)
    OR              reduce using rule 39 (boolean -> expression is term .)
    is              reduce using rule 39 (boolean -> expression is term .)
    CLOSEPAR        reduce using rule 39 (boolean -> expression is term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 65

    (32) boolean -> expression GEQ term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 32 (boolean -> expression GEQ term .)
    PLUS            reduce using rule 32 (boolean -> expression GEQ term .)
    MINUS           reduce using rule 32 (boolean -> expression GEQ term .)
    GT              reduce using rule 32 (boolean -> expression GEQ term .)
    GEQ             reduce using rule 32 (boolean -> expression GEQ term .)
    LT              reduce using rule 32 (boolean -> expression GEQ term .)
    LEQ             reduce using rule 32 (boolean -> expression GEQ term .)
    EQ              reduce using rule 32 (boolean -> expression GEQ term .)
    NEQ             reduce using rule 32 (boolean -> expression GEQ term .)
    AND             reduce using rule 32 (boolean -> expression GEQ term .)
    OR              reduce using rule 32 (boolean -> expression GEQ term .)
    is              reduce using rule 32 (boolean -> expression GEQ term .)
    CLOSEPAR        reduce using rule 32 (boolean -> expression GEQ term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 66

    (38) boolean -> expression OR term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 38 (boolean -> expression OR term .)
    PLUS            reduce using rule 38 (boolean -> expression OR term .)
    MINUS           reduce using rule 38 (boolean -> expression OR term .)
    GT              reduce using rule 38 (boolean -> expression OR term .)
    GEQ             reduce using rule 38 (boolean -> expression OR term .)
    LT              reduce using rule 38 (boolean -> expression OR term .)
    LEQ             reduce using rule 38 (boolean -> expression OR term .)
    EQ              reduce using rule 38 (boolean -> expression OR term .)
    NEQ             reduce using rule 38 (boolean -> expression OR term .)
    AND             reduce using rule 38 (boolean -> expression OR term .)
    OR              reduce using rule 38 (boolean -> expression OR term .)
    is              reduce using rule 38 (boolean -> expression OR term .)
    CLOSEPAR        reduce using rule 38 (boolean -> expression OR term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 67

    (34) boolean -> expression LEQ term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 34 (boolean -> expression LEQ term .)
    PLUS            reduce using rule 34 (boolean -> expression LEQ term .)
    MINUS           reduce using rule 34 (boolean -> expression LEQ term .)
    GT              reduce using rule 34 (boolean -> expression LEQ term .)
    GEQ             reduce using rule 34 (boolean -> expression LEQ term .)
    LT              reduce using rule 34 (boolean -> expression LEQ term .)
    LEQ             reduce using rule 34 (boolean -> expression LEQ term .)
    EQ              reduce using rule 34 (boolean -> expression LEQ term .)
    NEQ             reduce using rule 34 (boolean -> expression LEQ term .)
    AND             reduce using rule 34 (boolean -> expression LEQ term .)
    OR              reduce using rule 34 (boolean -> expression LEQ term .)
    is              reduce using rule 34 (boolean -> expression LEQ term .)
    CLOSEPAR        reduce using rule 34 (boolean -> expression LEQ term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 68

    (33) boolean -> expression LT term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 33 (boolean -> expression LT term .)
    PLUS            reduce using rule 33 (boolean -> expression LT term .)
    MINUS           reduce using rule 33 (boolean -> expression LT term .)
    GT              reduce using rule 33 (boolean -> expression LT term .)
    GEQ             reduce using rule 33 (boolean -> expression LT term .)
    LT              reduce using rule 33 (boolean -> expression LT term .)
    LEQ             reduce using rule 33 (boolean -> expression LT term .)
    EQ              reduce using rule 33 (boolean -> expression LT term .)
    NEQ             reduce using rule 33 (boolean -> expression LT term .)
    AND             reduce using rule 33 (boolean -> expression LT term .)
    OR              reduce using rule 33 (boolean -> expression LT term .)
    is              reduce using rule 33 (boolean -> expression LT term .)
    CLOSEPAR        reduce using rule 33 (boolean -> expression LT term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 69

    (40) expression -> expression PLUS term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 40 (expression -> expression PLUS term .)
    PLUS            reduce using rule 40 (expression -> expression PLUS term .)
    MINUS           reduce using rule 40 (expression -> expression PLUS term .)
    GT              reduce using rule 40 (expression -> expression PLUS term .)
    GEQ             reduce using rule 40 (expression -> expression PLUS term .)
    LT              reduce using rule 40 (expression -> expression PLUS term .)
    LEQ             reduce using rule 40 (expression -> expression PLUS term .)
    EQ              reduce using rule 40 (expression -> expression PLUS term .)
    NEQ             reduce using rule 40 (expression -> expression PLUS term .)
    AND             reduce using rule 40 (expression -> expression PLUS term .)
    OR              reduce using rule 40 (expression -> expression PLUS term .)
    is              reduce using rule 40 (expression -> expression PLUS term .)
    CLOSEPAR        reduce using rule 40 (expression -> expression PLUS term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 70

    (41) expression -> expression MINUS term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 41 (expression -> expression MINUS term .)
    PLUS            reduce using rule 41 (expression -> expression MINUS term .)
    MINUS           reduce using rule 41 (expression -> expression MINUS term .)
    GT              reduce using rule 41 (expression -> expression MINUS term .)
    GEQ             reduce using rule 41 (expression -> expression MINUS term .)
    LT              reduce using rule 41 (expression -> expression MINUS term .)
    LEQ             reduce using rule 41 (expression -> expression MINUS term .)
    EQ              reduce using rule 41 (expression -> expression MINUS term .)
    NEQ             reduce using rule 41 (expression -> expression MINUS term .)
    AND             reduce using rule 41 (expression -> expression MINUS term .)
    OR              reduce using rule 41 (expression -> expression MINUS term .)
    is              reduce using rule 41 (expression -> expression MINUS term .)
    CLOSEPAR        reduce using rule 41 (expression -> expression MINUS term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 71

    (36) boolean -> expression NEQ term .
    (42) term -> term . MUL factor
    (43) term -> term . DIV factor
    (44) term -> term . MOD factor

    TILDE           reduce using rule 36 (boolean -> expression NEQ term .)
    PLUS            reduce using rule 36 (boolean -> expression NEQ term .)
    MINUS           reduce using rule 36 (boolean -> expression NEQ term .)
    GT              reduce using rule 36 (boolean -> expression NEQ term .)
    GEQ             reduce using rule 36 (boolean -> expression NEQ term .)
    LT              reduce using rule 36 (boolean -> expression NEQ term .)
    LEQ             reduce using rule 36 (boolean -> expression NEQ term .)
    EQ              reduce using rule 36 (boolean -> expression NEQ term .)
    NEQ             reduce using rule 36 (boolean -> expression NEQ term .)
    AND             reduce using rule 36 (boolean -> expression NEQ term .)
    OR              reduce using rule 36 (boolean -> expression NEQ term .)
    is              reduce using rule 36 (boolean -> expression NEQ term .)
    CLOSEPAR        reduce using rule 36 (boolean -> expression NEQ term .)
    MUL             shift and go to state 31
    DIV             shift and go to state 33
    MOD             shift and go to state 32


state 72

    (10) statement -> def VAR OPENPAR . CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    CLOSEPAR        shift and go to state 82


state 73

    (23) if_statement -> if OPENPAR boolean CLOSEPAR . OPENCURLY statement CLOSECURLY
    (24) if_statement -> if OPENPAR boolean CLOSEPAR . print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> if OPENPAR boolean CLOSEPAR . print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> if OPENPAR boolean CLOSEPAR . print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    OPENCURLY       shift and go to state 83
    print           shift and go to state 84


state 74

    (19) statement -> print OPENPAR STRLIT CLOSEPAR . TILDE

    TILDE           shift and go to state 85


state 75

    (18) statement -> print OPENPAR expression CLOSEPAR . TILDE

    TILDE           shift and go to state 86


state 76

    (15) statement -> VAR ASSIGN OPENPAR STRLIT . CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (45) term -> STRLIT .

  ! shift/reduce conflict for CLOSEPAR resolved as shift
    CLOSEPAR        shift and go to state 87
    MUL             reduce using rule 45 (term -> STRLIT .)
    DIV             reduce using rule 45 (term -> STRLIT .)
    MOD             reduce using rule 45 (term -> STRLIT .)
    PLUS            reduce using rule 45 (term -> STRLIT .)
    MINUS           reduce using rule 45 (term -> STRLIT .)
    GT              reduce using rule 45 (term -> STRLIT .)
    GEQ             reduce using rule 45 (term -> STRLIT .)
    LT              reduce using rule 45 (term -> STRLIT .)
    LEQ             reduce using rule 45 (term -> STRLIT .)
    EQ              reduce using rule 45 (term -> STRLIT .)
    NEQ             reduce using rule 45 (term -> STRLIT .)
    AND             reduce using rule 45 (term -> STRLIT .)
    OR              reduce using rule 45 (term -> STRLIT .)
    is              reduce using rule 45 (term -> STRLIT .)

  ! CLOSEPAR        [ reduce using rule 45 (term -> STRLIT .) ]


state 77

    (14) statement -> VAR ASSIGN OPENPAR expression . CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (50) factor -> OPENPAR expression . CLOSEPAR
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term
    (31) boolean -> expression . GT term
    (32) boolean -> expression . GEQ term
    (33) boolean -> expression . LT term
    (34) boolean -> expression . LEQ term
    (35) boolean -> expression . EQ term
    (36) boolean -> expression . NEQ term
    (37) boolean -> expression . AND term
    (38) boolean -> expression . OR term
    (39) boolean -> expression . is term

    CLOSEPAR        shift and go to state 88
    PLUS            shift and go to state 42
    MINUS           shift and go to state 44
    GT              shift and go to state 35
    GEQ             shift and go to state 38
    LT              shift and go to state 41
    LEQ             shift and go to state 40
    EQ              shift and go to state 36
    NEQ             shift and go to state 45
    AND             shift and go to state 34
    OR              shift and go to state 39
    is              shift and go to state 37


state 78

    (8) statement -> VAR ASSIGN INTLIT TILDE .
    (28) while_stmt -> VAR ASSIGN INTLIT TILDE . while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement

    CLOSECURLY      reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    VAR             reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    def             reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    class           reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    print           reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    if              reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    STRLIT          reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    INTLIT          reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    FLTLIT          reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    DBLLIT          reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    OPENPAR         reduce using rule 8 (statement -> VAR ASSIGN INTLIT TILDE .)
    while           shift and go to state 89


state 79

    (17) statement -> VAR ASSIGN STRLIT TILDE . return OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> VAR ASSIGN STRLIT TILDE . print OPENPAR VAR CLOSEPAR TILDE

    return          shift and go to state 90
    print           shift and go to state 91


state 80

    (7) statement -> VAR ASSIGN expression TILDE .
    (16) statement -> VAR ASSIGN expression TILDE . return OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN expression TILDE . print OPENPAR VAR CLOSEPAR TILDE

  ! shift/reduce conflict for print resolved as shift
    CLOSECURLY      reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    VAR             reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    def             reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    class           reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    if              reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    STRLIT          reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    INTLIT          reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    FLTLIT          reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    DBLLIT          reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    OPENPAR         reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    return          shift and go to state 92
    print           shift and go to state 93

  ! print           [ reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .) ]


state 81

    (13) statement -> class VAR OPENCURLY statement . CLOSECURLY
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for FLTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for DBLLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 94
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! FLTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! DBLLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 26
    factor                         shift and go to state 13
    statement_list                 shift and go to state 27
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 82

    (10) statement -> def VAR OPENPAR CLOSEPAR . OPENCURLY statement CLOSECURLY end_def

    OPENCURLY       shift and go to state 95


state 83

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY . statement CLOSECURLY
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 96
    factor                         shift and go to state 13
    statement_list                 shift and go to state 20
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 84

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print . OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> if OPENPAR boolean CLOSEPAR print . OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> if OPENPAR boolean CLOSEPAR print . OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    OPENPAR         shift and go to state 97


state 85

    (19) statement -> print OPENPAR STRLIT CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    VAR             reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    def             reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    class           reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    print           reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    if              reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    STRLIT          reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    INTLIT          reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    FLTLIT          reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    DBLLIT          reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 19 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)


state 86

    (18) statement -> print OPENPAR expression CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    VAR             reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    def             reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    class           reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    print           reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    if              reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    STRLIT          reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    INTLIT          reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    FLTLIT          reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    DBLLIT          reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 18 (statement -> print OPENPAR expression CLOSEPAR TILDE .)


state 87

    (15) statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR . TILDE scan OPENPAR VAR CLOSEPAR TILDE

    TILDE           shift and go to state 98


state 88

    (14) statement -> VAR ASSIGN OPENPAR expression CLOSEPAR . TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (50) factor -> OPENPAR expression CLOSEPAR .

  ! shift/reduce conflict for TILDE resolved as shift
    TILDE           shift and go to state 99
    MUL             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    DIV             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    MOD             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    PLUS            reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    MINUS           reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    GT              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    GEQ             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    LT              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    LEQ             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    EQ              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    NEQ             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    AND             reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    OR              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)
    is              reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .)

  ! TILDE           [ reduce using rule 50 (factor -> OPENPAR expression CLOSEPAR .) ]


state 89

    (28) while_stmt -> VAR ASSIGN INTLIT TILDE while . OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement

    OPENPAR         shift and go to state 100


state 90

    (17) statement -> VAR ASSIGN STRLIT TILDE return . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 101


state 91

    (21) statement -> VAR ASSIGN STRLIT TILDE print . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 102


state 92

    (16) statement -> VAR ASSIGN expression TILDE return . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 103


state 93

    (20) statement -> VAR ASSIGN expression TILDE print . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 104


state 94

    (13) statement -> class VAR OPENCURLY statement CLOSECURLY .

    CLOSECURLY      reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    VAR             reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    def             reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    class           reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    print           reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    if              reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    STRLIT          reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    INTLIT          reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    FLTLIT          reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    DBLLIT          reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    OPENPAR         reduce using rule 13 (statement -> class VAR OPENCURLY statement CLOSECURLY .)


state 95

    (10) statement -> def VAR OPENPAR CLOSEPAR OPENCURLY . statement CLOSECURLY end_def
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 105
    factor                         shift and go to state 13
    statement_list                 shift and go to state 20
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 96

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement . CLOSECURLY
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for FLTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for DBLLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 106
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! FLTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! DBLLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 26
    factor                         shift and go to state 13
    statement_list                 shift and go to state 27
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 97

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR . STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR . INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR . expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 108
    INTLIT          shift and go to state 107
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 17
    boolean                        shift and go to state 6
    expression                     shift and go to state 109
    factor                         shift and go to state 13

state 98

    (15) statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE . scan OPENPAR VAR CLOSEPAR TILDE

    scan            shift and go to state 110


state 99

    (14) statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE . scan OPENPAR VAR CLOSEPAR TILDE

    scan            shift and go to state 111


state 100

    (28) while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR . boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 17
    boolean                        shift and go to state 112
    factor                         shift and go to state 13
    expression                     shift and go to state 49

state 101

    (17) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 113


state 102

    (21) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 114


state 103

    (16) statement -> VAR ASSIGN expression TILDE return OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 115


state 104

    (20) statement -> VAR ASSIGN expression TILDE print OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 116


state 105

    (10) statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement . CLOSECURLY end_def
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for FLTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for DBLLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 117
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! FLTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! DBLLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 26
    factor                         shift and go to state 13
    statement_list                 shift and go to state 27
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 106

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .

    CLOSECURLY      reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    VAR             reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    def             reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    class           reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    print           reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    if              reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    STRLIT          reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    INTLIT          reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    FLTLIT          reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    DBLLIT          reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    OPENPAR         reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)


state 107

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT . CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (47) factor -> INTLIT .

  ! shift/reduce conflict for CLOSEPAR resolved as shift
    CLOSEPAR        shift and go to state 118
    MUL             reduce using rule 47 (factor -> INTLIT .)
    DIV             reduce using rule 47 (factor -> INTLIT .)
    MOD             reduce using rule 47 (factor -> INTLIT .)
    PLUS            reduce using rule 47 (factor -> INTLIT .)
    MINUS           reduce using rule 47 (factor -> INTLIT .)
    GT              reduce using rule 47 (factor -> INTLIT .)
    GEQ             reduce using rule 47 (factor -> INTLIT .)
    LT              reduce using rule 47 (factor -> INTLIT .)
    LEQ             reduce using rule 47 (factor -> INTLIT .)
    EQ              reduce using rule 47 (factor -> INTLIT .)
    NEQ             reduce using rule 47 (factor -> INTLIT .)
    AND             reduce using rule 47 (factor -> INTLIT .)
    OR              reduce using rule 47 (factor -> INTLIT .)
    is              reduce using rule 47 (factor -> INTLIT .)

  ! CLOSEPAR        [ reduce using rule 47 (factor -> INTLIT .) ]


state 108

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT . CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (45) term -> STRLIT .

  ! shift/reduce conflict for CLOSEPAR resolved as shift
    CLOSEPAR        shift and go to state 119
    MUL             reduce using rule 45 (term -> STRLIT .)
    DIV             reduce using rule 45 (term -> STRLIT .)
    MOD             reduce using rule 45 (term -> STRLIT .)
    PLUS            reduce using rule 45 (term -> STRLIT .)
    MINUS           reduce using rule 45 (term -> STRLIT .)
    GT              reduce using rule 45 (term -> STRLIT .)
    GEQ             reduce using rule 45 (term -> STRLIT .)
    LT              reduce using rule 45 (term -> STRLIT .)
    LEQ             reduce using rule 45 (term -> STRLIT .)
    EQ              reduce using rule 45 (term -> STRLIT .)
    NEQ             reduce using rule 45 (term -> STRLIT .)
    AND             reduce using rule 45 (term -> STRLIT .)
    OR              reduce using rule 45 (term -> STRLIT .)
    is              reduce using rule 45 (term -> STRLIT .)

  ! CLOSEPAR        [ reduce using rule 45 (term -> STRLIT .) ]


state 109

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression . CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term
    (31) boolean -> expression . GT term
    (32) boolean -> expression . GEQ term
    (33) boolean -> expression . LT term
    (34) boolean -> expression . LEQ term
    (35) boolean -> expression . EQ term
    (36) boolean -> expression . NEQ term
    (37) boolean -> expression . AND term
    (38) boolean -> expression . OR term
    (39) boolean -> expression . is term

    CLOSEPAR        shift and go to state 120
    PLUS            shift and go to state 42
    MINUS           shift and go to state 44
    GT              shift and go to state 35
    GEQ             shift and go to state 38
    LT              shift and go to state 41
    LEQ             shift and go to state 40
    EQ              shift and go to state 36
    NEQ             shift and go to state 45
    AND             shift and go to state 34
    OR              shift and go to state 39
    is              shift and go to state 37


state 110

    (15) statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 121


state 111

    (14) statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 122


state 112

    (28) while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean . CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (30) expression -> boolean .

    CLOSEPAR        shift and go to state 123
    GT              reduce using rule 30 (expression -> boolean .)
    GEQ             reduce using rule 30 (expression -> boolean .)
    LT              reduce using rule 30 (expression -> boolean .)
    LEQ             reduce using rule 30 (expression -> boolean .)
    EQ              reduce using rule 30 (expression -> boolean .)
    NEQ             reduce using rule 30 (expression -> boolean .)
    AND             reduce using rule 30 (expression -> boolean .)
    OR              reduce using rule 30 (expression -> boolean .)
    is              reduce using rule 30 (expression -> boolean .)
    PLUS            reduce using rule 30 (expression -> boolean .)
    MINUS           reduce using rule 30 (expression -> boolean .)


state 113

    (17) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 124


state 114

    (21) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 125


state 115

    (16) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 126


state 116

    (20) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 127


state 117

    (10) statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY . end_def

    end_def         shift and go to state 128


state 118

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR . TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY

    TILDE           shift and go to state 129


state 119

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR . TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY

    TILDE           shift and go to state 130


state 120

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR . TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    TILDE           shift and go to state 131


state 121

    (15) statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 132


state 122

    (14) statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 133


state 123

    (28) while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR . OPENCURLY statement CLOSECURLY if_statement

    OPENCURLY       shift and go to state 134


state 124

    (17) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 135


state 125

    (21) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 136


state 126

    (16) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 137


state 127

    (20) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 138


state 128

    (10) statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .

    CLOSECURLY      reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    VAR             reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    def             reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    class           reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    print           reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    if              reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    STRLIT          reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    INTLIT          reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    FLTLIT          reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    DBLLIT          reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    OPENPAR         reduce using rule 10 (statement -> def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)


state 129

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE . else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY

    else            shift and go to state 139


state 130

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE . else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY

    else            shift and go to state 140


state 131

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE . else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    else            shift and go to state 141


state 132

    (15) statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 142


state 133

    (14) statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 143


state 134

    (28) while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY . statement CLOSECURLY if_statement
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 144
    factor                         shift and go to state 13
    statement_list                 shift and go to state 20
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 135

    (17) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    FLTLIT          reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    DBLLIT          reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 17 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)


state 136

    (21) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    FLTLIT          reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    DBLLIT          reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 21 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)


state 137

    (16) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    FLTLIT          reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    DBLLIT          reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 16 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)


state 138

    (20) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    FLTLIT          reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    DBLLIT          reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 20 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)


state 139

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else . OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY

    OPENCURLY       shift and go to state 145


state 140

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else . OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY

    OPENCURLY       shift and go to state 146


state 141

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else . OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    OPENCURLY       shift and go to state 147


state 142

    (15) statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 148


state 143

    (14) statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 149


state 144

    (28) while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement . CLOSECURLY if_statement
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . VAR ASSIGN INTLIT TILDE
    (9) statement -> . expression TILDE
    (10) statement -> . def VAR OPENPAR CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (13) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (14) statement -> . VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (18) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (19) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (22) statement -> . if_statement
    (27) statement -> . while_stmt
    (3) empty -> .
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY
    (28) while_stmt -> . VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for FLTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for DBLLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for FLTLIT resolved as shift
  ! shift/reduce conflict for DBLLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 150
    VAR             shift and go to state 15
    def             shift and go to state 22
    class           shift and go to state 16
    print           shift and go to state 10
    if              shift and go to state 8
    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! FLTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! DBLLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! FLTLIT          [ reduce using rule 3 (empty -> .) ]
  ! DBLLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 17
    while_stmt                     shift and go to state 19
    boolean                        shift and go to state 6
    statement                      shift and go to state 26
    factor                         shift and go to state 13
    statement_list                 shift and go to state 27
    if_statement                   shift and go to state 11
    expression                     shift and go to state 21
    empty                          shift and go to state 12

state 145

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY . print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY

    print           shift and go to state 151


state 146

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY . print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY

    print           shift and go to state 152


state 147

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY . print OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    print           shift and go to state 153


state 148

    (15) statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    FLTLIT          reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    DBLLIT          reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 15 (statement -> VAR ASSIGN OPENPAR STRLIT CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)


state 149

    (14) statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    FLTLIT          reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    DBLLIT          reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 14 (statement -> VAR ASSIGN OPENPAR expression CLOSEPAR TILDE scan OPENPAR VAR CLOSEPAR TILDE .)


state 150

    (28) while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY . if_statement
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (24) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY
    (25) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY
    (26) if_statement -> . if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    if              shift and go to state 8

    if_statement                   shift and go to state 154

state 151

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print . OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY

    OPENPAR         shift and go to state 155


state 152

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print . OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY

    OPENPAR         shift and go to state 156


state 153

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print . OPENPAR expression CLOSEPAR TILDE CLOSECURLY

    OPENPAR         shift and go to state 157


state 154

    (28) while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .

    CLOSECURLY      reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    VAR             reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    def             reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    class           reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    print           reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    if              reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    STRLIT          reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    INTLIT          reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    FLTLIT          reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    DBLLIT          reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)
    OPENPAR         reduce using rule 28 (while_stmt -> VAR ASSIGN INTLIT TILDE while OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY if_statement .)


state 155

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR . INTLIT CLOSEPAR TILDE CLOSECURLY

    INTLIT          shift and go to state 158


state 156

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR . STRLIT CLOSEPAR TILDE CLOSECURLY

    STRLIT          shift and go to state 159


state 157

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR . expression CLOSEPAR TILDE CLOSECURLY
    (29) expression -> . term
    (30) expression -> . boolean
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) term -> . term MUL factor
    (43) term -> . term DIV factor
    (44) term -> . term MOD factor
    (45) term -> . STRLIT
    (46) term -> . factor
    (31) boolean -> . expression GT term
    (32) boolean -> . expression GEQ term
    (33) boolean -> . expression LT term
    (34) boolean -> . expression LEQ term
    (35) boolean -> . expression EQ term
    (36) boolean -> . expression NEQ term
    (37) boolean -> . expression AND term
    (38) boolean -> . expression OR term
    (39) boolean -> . expression is term
    (47) factor -> . INTLIT
    (48) factor -> . FLTLIT
    (49) factor -> . DBLLIT
    (50) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 14
    INTLIT          shift and go to state 7
    FLTLIT          shift and go to state 18
    DBLLIT          shift and go to state 4
    OPENPAR         shift and go to state 5

    term                           shift and go to state 17
    boolean                        shift and go to state 6
    expression                     shift and go to state 160
    factor                         shift and go to state 13

state 158

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT . CLOSEPAR TILDE CLOSECURLY

    CLOSEPAR        shift and go to state 161


state 159

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT . CLOSEPAR TILDE CLOSECURLY

    CLOSEPAR        shift and go to state 162


state 160

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression . CLOSEPAR TILDE CLOSECURLY
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term
    (31) boolean -> expression . GT term
    (32) boolean -> expression . GEQ term
    (33) boolean -> expression . LT term
    (34) boolean -> expression . LEQ term
    (35) boolean -> expression . EQ term
    (36) boolean -> expression . NEQ term
    (37) boolean -> expression . AND term
    (38) boolean -> expression . OR term
    (39) boolean -> expression . is term

    CLOSEPAR        shift and go to state 163
    PLUS            shift and go to state 42
    MINUS           shift and go to state 44
    GT              shift and go to state 35
    GEQ             shift and go to state 38
    LT              shift and go to state 41
    LEQ             shift and go to state 40
    EQ              shift and go to state 36
    NEQ             shift and go to state 45
    AND             shift and go to state 34
    OR              shift and go to state 39
    is              shift and go to state 37


state 161

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR . TILDE CLOSECURLY

    TILDE           shift and go to state 164


state 162

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR . TILDE CLOSECURLY

    TILDE           shift and go to state 165


state 163

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR . TILDE CLOSECURLY

    TILDE           shift and go to state 166


state 164

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE . CLOSECURLY

    CLOSECURLY      shift and go to state 167


state 165

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE . CLOSECURLY

    CLOSECURLY      shift and go to state 168


state 166

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE . CLOSECURLY

    CLOSECURLY      shift and go to state 169


state 167

    (25) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .

    CLOSECURLY      reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    VAR             reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    def             reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    class           reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    print           reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    if              reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    STRLIT          reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    INTLIT          reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    FLTLIT          reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    DBLLIT          reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)
    OPENPAR         reduce using rule 25 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR INTLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR INTLIT CLOSEPAR TILDE CLOSECURLY .)


state 168

    (24) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .

    CLOSECURLY      reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    VAR             reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    def             reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    class           reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    print           reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    if              reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    STRLIT          reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    INTLIT          reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    FLTLIT          reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    DBLLIT          reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)
    OPENPAR         reduce using rule 24 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR STRLIT CLOSEPAR TILDE else OPENCURLY print OPENPAR STRLIT CLOSEPAR TILDE CLOSECURLY .)


state 169

    (26) if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .

    CLOSECURLY      reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    VAR             reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    def             reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    class           reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    print           reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    if              reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    STRLIT          reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    INTLIT          reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    FLTLIT          reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    DBLLIT          reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)
    OPENPAR         reduce using rule 26 (if_statement -> if OPENPAR boolean CLOSEPAR print OPENPAR expression CLOSEPAR TILDE else OPENCURLY print OPENPAR expression CLOSEPAR TILDE CLOSECURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 3 resolved as shift
WARNING: shift/reduce conflict for def in state 3 resolved as shift
WARNING: shift/reduce conflict for class in state 3 resolved as shift
WARNING: shift/reduce conflict for print in state 3 resolved as shift
WARNING: shift/reduce conflict for if in state 3 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 3 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 3 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 3 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 3 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 3 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 9 resolved as shift
WARNING: shift/reduce conflict for VAR in state 9 resolved as shift
WARNING: shift/reduce conflict for def in state 9 resolved as shift
WARNING: shift/reduce conflict for class in state 9 resolved as shift
WARNING: shift/reduce conflict for print in state 9 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 9 resolved as shift
WARNING: shift/reduce conflict for VAR in state 9 resolved as shift
WARNING: shift/reduce conflict for def in state 9 resolved as shift
WARNING: shift/reduce conflict for class in state 9 resolved as shift
WARNING: shift/reduce conflict for print in state 9 resolved as shift
WARNING: shift/reduce conflict for if in state 9 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 9 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 9 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 9 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 9 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 9 resolved as shift
WARNING: shift/reduce conflict for VAR in state 26 resolved as shift
WARNING: shift/reduce conflict for def in state 26 resolved as shift
WARNING: shift/reduce conflict for class in state 26 resolved as shift
WARNING: shift/reduce conflict for print in state 26 resolved as shift
WARNING: shift/reduce conflict for VAR in state 26 resolved as shift
WARNING: shift/reduce conflict for def in state 26 resolved as shift
WARNING: shift/reduce conflict for class in state 26 resolved as shift
WARNING: shift/reduce conflict for print in state 26 resolved as shift
WARNING: shift/reduce conflict for if in state 26 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 26 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 26 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 26 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 26 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 26 resolved as shift
WARNING: shift/reduce conflict for CLOSEPAR in state 51 resolved as shift
WARNING: shift/reduce conflict for TILDE in state 54 resolved as shift
WARNING: shift/reduce conflict for TILDE in state 55 resolved as shift
WARNING: shift/reduce conflict for VAR in state 57 resolved as shift
WARNING: shift/reduce conflict for def in state 57 resolved as shift
WARNING: shift/reduce conflict for class in state 57 resolved as shift
WARNING: shift/reduce conflict for print in state 57 resolved as shift
WARNING: shift/reduce conflict for if in state 57 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 57 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 57 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 57 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 57 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 57 resolved as shift
WARNING: shift/reduce conflict for CLOSEPAR in state 76 resolved as shift
WARNING: shift/reduce conflict for print in state 80 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 81 resolved as shift
WARNING: shift/reduce conflict for VAR in state 81 resolved as shift
WARNING: shift/reduce conflict for def in state 81 resolved as shift
WARNING: shift/reduce conflict for class in state 81 resolved as shift
WARNING: shift/reduce conflict for print in state 81 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 81 resolved as shift
WARNING: shift/reduce conflict for VAR in state 81 resolved as shift
WARNING: shift/reduce conflict for def in state 81 resolved as shift
WARNING: shift/reduce conflict for class in state 81 resolved as shift
WARNING: shift/reduce conflict for print in state 81 resolved as shift
WARNING: shift/reduce conflict for if in state 81 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 81 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 81 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 81 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 81 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 81 resolved as shift
WARNING: shift/reduce conflict for VAR in state 83 resolved as shift
WARNING: shift/reduce conflict for def in state 83 resolved as shift
WARNING: shift/reduce conflict for class in state 83 resolved as shift
WARNING: shift/reduce conflict for print in state 83 resolved as shift
WARNING: shift/reduce conflict for if in state 83 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 83 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 83 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 83 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 83 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 83 resolved as shift
WARNING: shift/reduce conflict for TILDE in state 88 resolved as shift
WARNING: shift/reduce conflict for VAR in state 95 resolved as shift
WARNING: shift/reduce conflict for def in state 95 resolved as shift
WARNING: shift/reduce conflict for class in state 95 resolved as shift
WARNING: shift/reduce conflict for print in state 95 resolved as shift
WARNING: shift/reduce conflict for if in state 95 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 95 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 95 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 95 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 95 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 95 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 96 resolved as shift
WARNING: shift/reduce conflict for VAR in state 96 resolved as shift
WARNING: shift/reduce conflict for def in state 96 resolved as shift
WARNING: shift/reduce conflict for class in state 96 resolved as shift
WARNING: shift/reduce conflict for print in state 96 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 96 resolved as shift
WARNING: shift/reduce conflict for VAR in state 96 resolved as shift
WARNING: shift/reduce conflict for def in state 96 resolved as shift
WARNING: shift/reduce conflict for class in state 96 resolved as shift
WARNING: shift/reduce conflict for print in state 96 resolved as shift
WARNING: shift/reduce conflict for if in state 96 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 96 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 96 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 96 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 96 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 96 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 105 resolved as shift
WARNING: shift/reduce conflict for VAR in state 105 resolved as shift
WARNING: shift/reduce conflict for def in state 105 resolved as shift
WARNING: shift/reduce conflict for class in state 105 resolved as shift
WARNING: shift/reduce conflict for print in state 105 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 105 resolved as shift
WARNING: shift/reduce conflict for VAR in state 105 resolved as shift
WARNING: shift/reduce conflict for def in state 105 resolved as shift
WARNING: shift/reduce conflict for class in state 105 resolved as shift
WARNING: shift/reduce conflict for print in state 105 resolved as shift
WARNING: shift/reduce conflict for if in state 105 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 105 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 105 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 105 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 105 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 105 resolved as shift
WARNING: shift/reduce conflict for CLOSEPAR in state 107 resolved as shift
WARNING: shift/reduce conflict for CLOSEPAR in state 108 resolved as shift
WARNING: shift/reduce conflict for VAR in state 134 resolved as shift
WARNING: shift/reduce conflict for def in state 134 resolved as shift
WARNING: shift/reduce conflict for class in state 134 resolved as shift
WARNING: shift/reduce conflict for print in state 134 resolved as shift
WARNING: shift/reduce conflict for if in state 134 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 134 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 134 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 134 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 134 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 134 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 144 resolved as shift
WARNING: shift/reduce conflict for VAR in state 144 resolved as shift
WARNING: shift/reduce conflict for def in state 144 resolved as shift
WARNING: shift/reduce conflict for class in state 144 resolved as shift
WARNING: shift/reduce conflict for print in state 144 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 144 resolved as shift
WARNING: shift/reduce conflict for VAR in state 144 resolved as shift
WARNING: shift/reduce conflict for def in state 144 resolved as shift
WARNING: shift/reduce conflict for class in state 144 resolved as shift
WARNING: shift/reduce conflict for print in state 144 resolved as shift
WARNING: shift/reduce conflict for if in state 144 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 144 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 144 resolved as shift
WARNING: shift/reduce conflict for FLTLIT in state 144 resolved as shift
WARNING: shift/reduce conflict for DBLLIT in state 144 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 144 resolved as shift
WARNING: reduce/reduce conflict in state 9 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 9
WARNING: reduce/reduce conflict in state 26 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 26
WARNING: reduce/reduce conflict in state 27 resolved using rule (statement -> statement_list)
WARNING: rejected rule (statement_list -> statement statement_list) in state 27
WARNING: reduce/reduce conflict in state 81 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 81
WARNING: reduce/reduce conflict in state 96 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 96
WARNING: reduce/reduce conflict in state 105 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 105
WARNING: reduce/reduce conflict in state 144 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 144
WARNING: Rule (statement_list -> statement) is never reduced
WARNING: Rule (statement_list -> statement statement_list) is never reduced
